pub fn aoc_5() {
    let program = [
        3, 225, 1, 225, 6, 6, 1100, 1, 238, 225, 104, 0, 1101, 69, 55, 225, 1001, 144, 76, 224,
        101, -139, 224, 224, 4, 224, 1002, 223, 8, 223, 1001, 224, 3, 224, 1, 223, 224, 223, 1102,
        60, 49, 225, 1102, 51, 78, 225, 1101, 82, 33, 224, 1001, 224, -115, 224, 4, 224, 1002, 223,
        8, 223, 1001, 224, 3, 224, 1, 224, 223, 223, 1102, 69, 5, 225, 2, 39, 13, 224, 1001, 224,
        -4140, 224, 4, 224, 102, 8, 223, 223, 101, 2, 224, 224, 1, 224, 223, 223, 101, 42, 44, 224,
        101, -120, 224, 224, 4, 224, 102, 8, 223, 223, 101, 3, 224, 224, 1, 223, 224, 223, 1102,
        68, 49, 224, 101, -3332, 224, 224, 4, 224, 1002, 223, 8, 223, 1001, 224, 4, 224, 1, 224,
        223, 223, 1101, 50, 27, 225, 1102, 5, 63, 225, 1002, 139, 75, 224, 1001, 224, -3750, 224,
        4, 224, 1002, 223, 8, 223, 1001, 224, 3, 224, 1, 223, 224, 223, 102, 79, 213, 224, 1001,
        224, -2844, 224, 4, 224, 102, 8, 223, 223, 1001, 224, 4, 224, 1, 223, 224, 223, 1, 217, 69,
        224, 1001, 224, -95, 224, 4, 224, 102, 8, 223, 223, 1001, 224, 5, 224, 1, 223, 224, 223,
        1102, 36, 37, 225, 1101, 26, 16, 225, 4, 223, 99, 0, 0, 0, 677, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 1105, 0, 99999, 1105, 227, 247, 1105, 1, 99999, 1005, 227, 99999, 1005, 0, 256, 1105,
        1, 99999, 1106, 227, 99999, 1106, 0, 265, 1105, 1, 99999, 1006, 0, 99999, 1006, 227, 274,
        1105, 1, 99999, 1105, 1, 280, 1105, 1, 99999, 1, 225, 225, 225, 1101, 294, 0, 0, 105, 1, 0,
        1105, 1, 99999, 1106, 0, 300, 1105, 1, 99999, 1, 225, 225, 225, 1101, 314, 0, 0, 106, 0, 0,
        1105, 1, 99999, 1107, 677, 677, 224, 102, 2, 223, 223, 1006, 224, 329, 1001, 223, 1, 223,
        1108, 677, 677, 224, 1002, 223, 2, 223, 1006, 224, 344, 1001, 223, 1, 223, 107, 226, 226,
        224, 1002, 223, 2, 223, 1006, 224, 359, 101, 1, 223, 223, 1008, 226, 226, 224, 102, 2, 223,
        223, 1005, 224, 374, 1001, 223, 1, 223, 1107, 226, 677, 224, 1002, 223, 2, 223, 1006, 224,
        389, 1001, 223, 1, 223, 1008, 677, 226, 224, 1002, 223, 2, 223, 1005, 224, 404, 1001, 223,
        1, 223, 7, 677, 226, 224, 102, 2, 223, 223, 1005, 224, 419, 1001, 223, 1, 223, 1008, 677,
        677, 224, 1002, 223, 2, 223, 1006, 224, 434, 1001, 223, 1, 223, 108, 226, 226, 224, 102, 2,
        223, 223, 1006, 224, 449, 1001, 223, 1, 223, 108, 677, 677, 224, 102, 2, 223, 223, 1006,
        224, 464, 1001, 223, 1, 223, 107, 226, 677, 224, 1002, 223, 2, 223, 1005, 224, 479, 101, 1,
        223, 223, 1108, 226, 677, 224, 1002, 223, 2, 223, 1006, 224, 494, 1001, 223, 1, 223, 107,
        677, 677, 224, 1002, 223, 2, 223, 1006, 224, 509, 101, 1, 223, 223, 7, 677, 677, 224, 102,
        2, 223, 223, 1006, 224, 524, 1001, 223, 1, 223, 1007, 226, 677, 224, 1002, 223, 2, 223,
        1005, 224, 539, 1001, 223, 1, 223, 8, 226, 677, 224, 1002, 223, 2, 223, 1005, 224, 554,
        101, 1, 223, 223, 8, 677, 677, 224, 102, 2, 223, 223, 1005, 224, 569, 101, 1, 223, 223, 7,
        226, 677, 224, 102, 2, 223, 223, 1006, 224, 584, 1001, 223, 1, 223, 1007, 226, 226, 224,
        102, 2, 223, 223, 1006, 224, 599, 1001, 223, 1, 223, 1107, 677, 226, 224, 1002, 223, 2,
        223, 1006, 224, 614, 1001, 223, 1, 223, 1108, 677, 226, 224, 1002, 223, 2, 223, 1005, 224,
        629, 1001, 223, 1, 223, 1007, 677, 677, 224, 102, 2, 223, 223, 1006, 224, 644, 1001, 223,
        1, 223, 108, 226, 677, 224, 102, 2, 223, 223, 1005, 224, 659, 101, 1, 223, 223, 8, 677,
        226, 224, 1002, 223, 2, 223, 1006, 224, 674, 1001, 223, 1, 223, 4, 223, 99, 226,
    ];
    execute(program.clone().to_vec(), 1);
    execute(program.clone().to_vec(), 5);
}

fn execute(mut program: Vec<i32>, input: i32) -> i32 {
    let mut pc = 0;
    let mut output = 0;
    while pc < program.len() {
        let opcode = program[pc] % 100;
        let pm = ((program[pc] / 100) % 10) == 0;
        let p2 = ((program[pc] / 1000) % 10) == 0;
        match opcode {
            1 => {
                let arg = get_arg(&program, pc + 1, pm);
                let arg2 = get_arg(&program, pc + 2, p2);
                let add3 = program[pc + 3] as usize;
                program[add3] = arg + arg2;
                pc += 4;
            }
            2 => {
                let arg = get_arg(&program, pc + 1, pm);
                let arg2 = get_arg(&program, pc + 2, p2);
                let add3 = program[pc + 3] as usize;
                program[add3] = arg * arg2;
                pc += 4;
            }
            3 => {
                let input_addr = program[pc + 1] as usize;
                program[input_addr] = input;
                println!("CHANGED point {} to value {}", input_addr, input);
                pc += 2;
            }
            4 => {
                output = get_arg(&program, pc + 1, pm);
                println!("OUTPUT: {}", output);
                pc += 2;
            }
            5 => {
                let arg = get_arg(&program, pc + 1, pm);
                let arg2 = get_arg(&program, pc + 2, p2);
                pc = if arg != 0 { arg2 as usize } else { pc + 3 };
            }
            6 => {
                let arg = get_arg(&program, pc + 1, pm);
                let arg2 = get_arg(&program, pc + 2, p2);
                pc = if arg == 0 { arg2 as usize } else { pc + 3 };
            }
            7 => {
                let arg = get_arg(&program, pc + 1, pm);
                let arg2 = get_arg(&program, pc + 2, p2);
                let add3 = program[pc + 3] as usize;
                program[add3] = if arg < arg2 { 1 } else { 0 };
                pc += 4;
            }
            8 => {
                let arg = get_arg(&program, pc + 1, pm);
                let arg2 = get_arg(&program, pc + 2, p2);
                let add3 = program[pc + 3] as usize;
                program[add3] = if arg == arg2 { 1 } else { 0 };
                pc += 4;
            }
            99 => break,
            opcode => panic!("Bad opcode: {}", opcode),
        }
    }
    output
}

fn get_arg(program: &[i32], pc: usize, pm: bool) -> i32 {
    let addr = program[pc];
    if pm {
        program[addr as usize]
    } else {
        addr
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn immediate_mode() {
        assert_eq!(execute([1, 0, 0, 0, 99].to_vec(), 1), 0);
        assert_eq!(execute([2, 3, 0, 3, 99].to_vec(), 1), 0);
        assert_eq!(execute([2, 4, 4, 5, 99, 0].to_vec(), 1), 0);
        assert_eq!(execute([1, 1, 1, 4, 99, 5, 6, 0, 99].to_vec(), 1), 0);
    }

    #[test]
    fn jumps() {
        let prog_0 = [3, 12, 6, 12, 15, 1, 13, 14, 13, 4, 13, 99, -1, 0, 1, 9];
        assert_eq!(execute(prog_0.to_vec(), 0), 0);
        assert_eq!(execute(prog_0.to_vec(), 42), 1);

        let prog_1 = [3, 3, 1105, -1, 9, 1101, 0, 0, 12, 4, 12, 99, 1];
        assert_eq!(execute(prog_1.to_vec(), 0), 0);
        assert_eq!(execute(prog_1.to_vec(), 42), 1);

        let prog_2 = [
            3, 21, 1008, 21, 8, 20, 1005, 20, 22, 107, 8, 21, 20, 1006, 20, 31, 1106, 0, 36, 98, 0,
            0, 1002, 21, 125, 20, 4, 20, 1105, 1, 46, 104, 999, 1105, 1, 46, 1101, 1000, 1, 20, 4,
            20, 1105, 1, 46, 98, 99,
        ];
        assert_eq!(execute(prog_2.to_vec(), 7), 999);
        assert_eq!(execute(prog_2.to_vec(), 8), 1000);
        assert_eq!(execute(prog_2.to_vec(), 9), 1001);
    }
}
